#!/usr/bin/env python3
"""Tool functions for query generation, evaluation, and ranking."""

import os
import json
import pandas as pd
from typing import Dict, Any

os.environ['GRPC_VERBOSITY'] = 'ERROR'
os.environ['GLOG_minloglevel'] = '2'

from dotenv import load_dotenv
load_dotenv()

from google.adk.tools.tool_context import ToolContext

_df_instance = None
_filtered_df_cache = None

def set_dataframe(df: pd.DataFrame):
    """Set global DataFrame reference"""
    global _df_instance
    _df_instance = df

def get_filtered_df():
    """Get cached filtered DataFrame"""
    global _filtered_df_cache
    return _filtered_df_cache


def generate_pandas_query(tool_context: ToolContext, pandas_query: str) -> Dict[str, str]:
    """Store pandas query generated by agent, cleaning markdown if present."""
    state = tool_context.state

    query = pandas_query.strip()
    if '```' in query:
        query = query.split('```')[1]
        if query.startswith('python'):
            query = query[6:]
        query = query.strip()

    state['pandas_query'] = query
    state['previous_query'] = query

    attempt = state.get('attempt_number', 1)
    is_refinement = bool(state.get('feedback', ''))

    print(f"\n   {'🔄 REFINEMENT' if is_refinement else '📝 INITIAL'} (Iteration {attempt}):")
    print(f"   Query: {query}")
    if is_refinement:
        print(f"   Previous count: {state.get('previous_result_count', 0)}")

    return {"status": "success", "query": query[:100] + "..." if len(query) > 100 else query}


def execute_and_evaluate_query(tool_context: ToolContext) -> Dict[str, Any]:
    """Execute pandas query, evaluate result count, and set approval status."""
    global _df_instance
    if _df_instance is None:
        return {"status": "error", "message": "DataFrame not initialized"}

    state = tool_context.state
    pandas_query = state.get('pandas_query', '')
    user_criteria = state.get('user_criteria', '')
    attempt_number = state.get('attempt_number', 1)

    if not pandas_query:
        state['query_approved'] = False
        state['feedback'] = "No query generated"
        return {"status": "error", "message": "No query to evaluate"}

    try:
        safe_context = {'df': _df_instance, 'pd': pd}
        result_df = eval(pandas_query, {"__builtins__": {}}, safe_context)

        if not isinstance(result_df, pd.DataFrame):
            state['query_approved'] = False
            state['feedback'] = f"Query returned {type(result_df)} instead of DataFrame."
            state['result_count'] = 0
            return {"status": "error", "message": "Wrong return type"}

        result_count = len(result_df)
        state['result_count'] = result_count
        state['previous_result_count'] = result_count

        global _filtered_df_cache
        _filtered_df_cache = result_df

        # Sort by EPS CAGR for quality results
        if 'cagr_eps_forecast_10yr' in result_df.columns:
            result_df_sorted = result_df.sort_values('cagr_eps_forecast_10yr', ascending=False, na_position='last')
        else:
            result_df_sorted = result_df

        state['filtered_companies'] = result_df_sorted.head(50).to_dict('records')

    except Exception as e:
        state['query_approved'] = False
        state['feedback'] = f"Query execution error: {str(e)}"
        state['result_count'] = 0
        return {"status": "error", "message": str(e)}

    print(f"   ✓ Result count: {result_count}")
    if result_count > 50 and 'cagr_eps_forecast_10yr' in result_df.columns:
        print(f"   📊 Sorted by cagr_eps_forecast_10yr (descending) - top 50 selected for ranking")

    if result_count == 0:
        reason = "Query returned 0 results"
        feedback_text = f"{reason}. Loosen ONLY numerical thresholds - DO NOT change categorical filters."
    elif result_count < 5:
        reason = f"Only {result_count} results (minimum target: 5)"
        feedback_text = f"{reason}. Loosen ONLY numerical thresholds - KEEP categorical filters unchanged."
    elif result_count <= 100:
        reason = f"{result_count} results is adequate (target: 5-100)"
        feedback_text = f"Query approved with {result_count} results"
    else:
        reason = f"Too many results: {result_count} (target: 5-100)"
        feedback_text = f"{reason}. Tighten ONLY numerical thresholds - DO NOT change categorical filters."

    state['feedback'] = feedback_text
    state['attempt_number'] = attempt_number + 1

    if result_count >= 5 and result_count <= 100:
        state['query_approved'] = True
        tool_context.actions.escalate = True
        print(f"   ✅ APPROVED: {reason}")
        print(f"   🛑 Exiting refinement loop")
        return {"status": "approved", "result_count": result_count}
    else:
        state['query_approved'] = False
        print(f"   ❌ REJECTED: {reason}")
        print(f"   💡 Refinement guidance: {feedback_text}")
        return {"status": "rejected", "result_count": result_count, "feedback": feedback_text}


def rank_companies(tool_context: ToolContext) -> str:
    """Return filtered companies data for agent to analyze and rank."""
    state = tool_context.state
    filtered_companies = state.get('filtered_companies', [])
    user_criteria = state.get('user_criteria', '')
    top_n = state.get('top_n', 10)

    if not filtered_companies:
        return json.dumps({"error": "No filtered companies available to rank"})

    print(f"\n   📊 Providing {len(filtered_companies)} companies to agent for ranking")
    sample_tickers = [c.get('ticker', 'N/A') for c in filtered_companies[:5]]
    print(f"   📋 Available tickers (sample): {', '.join(sample_tickers)}")

    return json.dumps({
        "status": "success",
        "user_criteria": user_criteria,
        "top_n": top_n,
        "filtered_companies": filtered_companies[:50],
        "instructions": f"Rank these companies based on: '{user_criteria}'. Use ACTUAL tickers from filtered_companies. Generate top {top_n} rankings with ticker, rank, score, score_breakdown, recommendation_reason, investment_thesis. Then call store_rankings()."
    }, indent=2)


def store_rankings(tool_context: ToolContext, rankings_json: str) -> Dict[str, Any]:
    """Parse and store agent-generated rankings, enriching with company data."""
    state = tool_context.state
    filtered_companies = state.get('filtered_companies', [])
    top_n = state.get('top_n', 10)

    response_text = rankings_json.strip()
    if '```json' in response_text:
        json_start = response_text.find('```json') + 7
        json_end = response_text.find('```', json_start)
        response_text = response_text[json_start:json_end].strip()
    elif '```' in response_text:
        json_start = response_text.find('```') + 3
        json_end = response_text.find('```', json_start)
        response_text = response_text[json_start:json_end].strip()

    try:
        rankings = json.loads(response_text)

        for rank_data in rankings[:top_n]:
            ticker = rank_data.get('ticker', '')
            company_data = next((c for c in filtered_companies if c.get('ticker') == ticker), {})

            rank_data['company_name'] = company_data.get('name', 'N/A')
            rank_data['key_metrics'] = {
                'market_cap': company_data.get('market_cap'),
                'sector': company_data.get('sector'),
                'cagr_eps_forecast_10yr': company_data.get('cagr_eps_forecast_10yr'),
                'valuation_classification': company_data.get('valuation_classification'),
                'growth_classification': company_data.get('growth_classification'),
                'cyclicality_classification': company_data.get('cyclicality_classification')
            }

        state['rankings'] = rankings[:top_n]
        print(f"   ✅ Stored {len(rankings[:top_n])} ranked companies")
        return {"status": "success", "ranked_count": len(rankings[:top_n])}

    except json.JSONDecodeError as e:
        return {"status": "error", "message": f"Failed to parse rankings JSON: {str(e)}"}
